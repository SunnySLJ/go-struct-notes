##mutex源码分析以及总结
    mutex结构体包含state互斥锁的状态和sema信号量
    state内部实现时把该变量分成四份记录mutex的四种状态

    Waiter: 表示阻塞等待锁的协程个数，协程解锁时根据此值来判断是否需要释放信号量。
    Starving：表示该Mutex是否处理饥饿状态， 0：没有饥饿 1：饥饿状态，说明有协程阻塞了超过1ms。
    Woken: 表示是否有协程已被唤醒，0：没有协程唤醒 1：已有协程唤醒，正在加锁过程中。
    Locked: 表示该Mutex是否已被锁定，0：没有锁定 1：已被锁定。
    
    Lock方法，当前状态是unlock的，直接cas加锁成功，其他goroutine陷入阻塞。
    如果当前已经lock，若是非饥饿模式下，则会进入自旋获取锁，这也是为了加锁失败不必立即转入阻塞，有一定机会获取到锁，避免协程的切换
    如果加锁的协程特别多，每次都通过自旋获得锁，那么之前被阻塞的进程将很难获得锁，从而进入饥饿状态
    阻塞前会判断自上次阻塞到本次阻塞经过了多长时间，如果超过1ms的话，会将Mutex标记为”饥饿”模式

    Unlock方法，如果当前没有协程抢占加锁，则不释放信号量了。
    判断当前是否处于饥饿状态。正常状态下设置新的state, 这里通过信号量会唤醒一个阻塞的goroutine去获取锁
    饥饿模式下，直接将锁的拥有权传给等待队列中的第一个
##分析
    使用defer避免死锁

参考文档：
- [Go并发 - Mutex源码解析](https://juejin.cn/post/6958979192574705701)
    
