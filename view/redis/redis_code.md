缓存雪崩：缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。缓存雪崩通常因为缓存服务器宕机、缓存的 key 设置了相同的过期时间等引起。

缓存击穿：一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到 DB ，造成瞬时DB请求量大、压力骤增。

缓存穿透：查询一个不存在的数据，因为不存在则不会写到缓存中，所以每次都会去请求 DB，如果瞬间流量过大，穿透到 DB，导致宕机

##
    缓存穿透
    缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。
    解决方案：
    接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
    从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击
    go-zero使用预先设置好的placeholder判断获取到的缓存是否为空判断来防止缓存穿透
    
    
    缓存击穿
    缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力
    解决方案:设置热点数据永远不过期。
    缓存中没有数据的时候，从数据库获取数据时候加锁，可以是互斥锁，获取到
    
    
    缓存雪崩
    描述：
    缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是， 缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。
    解决方案：
    缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
    如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。
    设置热点数据永远不过期。
    go-zero中缓存设计
    缓存穿透:
      设置了传入的key取不到缓存和数据库的值，设置有效期默认60秒的统一值，下次再请求直接返回该值，防止对数据库攻击产生压力。
      从缓存和数据库都取不到数据的话，一样将数据库空值放入缓存中，设置30s有效期避免使用同一个id对数据库攻击压力大
      使用布隆过滤器
      布隆过滤器为什么会产生冲突，会根据key计算hash值，可能与布隆过滤器中存放的元素hash产生冲突都是为1，布隆可能会产生误判可能存在。
      如何解决这个问题：二进制数组长度设置比较大，可以减少布隆误判的概率。
      1. 接口层实现api限流、用户授权、id检查等 黑名单和白名单；
      1. 从缓存和数据库都取不到数据的话，一样将数据库空值放入缓存中，设置30s有效期避免使用同一个id对数据库攻击压力大(即设置同一用户获取为空值是返回的值统一并且)
      2. 使用布隆过滤器

      缓存击穿:设置热点数据永远不过期。缓存中没有数据的时候，从数据库获取数据时候加锁，可以是互斥锁来防止缓存击穿。
     缓存雪崩:设置缓存的时候，每个缓存生成的过期时间为随机的，防止同一时间大量数据过期直接访问到数据库，用barrier来确保一个进程内只有一个请求去加载key对应的数据
     go-zero内置了缓存访问量、访问命中率统计。
     更新缓存操作：先更新数据到DB，删除缓存，然后再次查询的时候会将数据添加到缓存中
     当多行查询比较频繁的时候，并且量还挺大的时候可以考虑引进biz redis，即将多行查询出的数据按照多行中的key拼接生成key，并将数据存储到redis中，如果访问量超级高，可以考虑存储到内存。当然也有go-zero中的cache库
     go-zero中定时任务，队列，延时也可以用go-queue，有两种模式，dq和kq，dq依赖于beanstalkd，分布式，可存储，延迟、定时设置，关机重启可以重新执行，消息不会丢失，beanstalkd是依赖于rabbitmq子下的一款轻量级的分布式内存队列系统，kq就是依赖于kafka，
     go-quere中使用redis的setnx保证每条消息只被消费一次

##redis lock 既然是锁，首先想到的一个作用就是：防重复点击，在一个时间点只有一个请求产生效果。

